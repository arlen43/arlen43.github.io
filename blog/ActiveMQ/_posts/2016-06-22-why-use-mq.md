---
layout: post
title: 为什么使用MQ
tags: ActiveMQ
source: virgin
---

## 为什么要用MQ
我觉得，在用一个新东西时首先得知道为什么要用它。在没有用MQ时，我们一般是通过TCP或者UDP来处理的，就跟TCP或UDP直接交互的方式作为比较，如果不使用MQ，以下问题请问怎么处理？

* 如何处理网络组件？将其强制划分为“客户端”、“服务端”么？

  *原始方式*：消息发送端必须绑定为“客户端”，接收端必须指定为“服务端”

  *MQ*：抽象出消息传输层，所谓客户端、服务端，均是根据应用来确定

* 如何动态处理网络组件？比如，今天的“服务端”是老版本的，明天“服务端”要上新版本，如何切换？

  *原始方式*：要升级，消息层的所有代码全需升级

  *MQ*：只需要关注业务代码升级即可

* 所谓的“服务端”如何处理I/O阻塞呢？是应用程序阻塞还是后台处理？

  *原始方式*：要么阻塞，要么select，也就是后台处理，弊端：阻塞的话，性能低；后台处理的话，服务端得承受无限的压力

  *MQ*：相当于缓存，消息排队，消费者有资源就来消费，否则放在队列中

* 如何表示在线路上的消息？如何将消息组装成帧，使其很容易被读写，避免缓冲区溢出？

  *原始方式*：自己组装底层报文，如C++的char数组，java的byte数组，写一大堆代码，来控制缓冲区等，封装报文头，定义报文结束标识等等

  *MQ*：线路上的消息即队列中的消息，消息组装有标准的消息头，缓冲区也即队列大小，可自己配置

* “客户端”如何处理不能立即传输的消息？“服务端”如何处理不能立即接收的消息？丢弃还是存库还是放入内存队列？

  *原始方式*：放入内存队列，要么放入数据库，定时发送；服务端要么丢弃，要么放入内存队列，风险很大

  *MQ*：对消息排队，提供持久化机制，保证数据安全

* 如果我们需要更换个网络协议，比如用多播来代替TCP单播，用IPv6取代IPv4？

  *原始方式*：更改底层代码，一大堆

  *MQ*：全是可配置的

* 如何处理丢失的消息？是等待 新数据，还是要求重发？

  *原始方式*：要么不管处理新消息，要么要求重发，相当于写了一次TCP协议

  *MQ*：通过容错机制，保证消息不丢失，其余我也不晓得啦。。。

* 如何路由消息？可否将同样的消息发送给多个接收者？可否发送应答给原来的请求者？

  *原始方式*：根据协议来，指定地址；发送给多个，要么变更协议，要么代码循环一个个发；要发送应答，如果是异步处理，必须记录请求者地址等

  *MQ*：有生产者、消费者，完全由用户配置；有两种模式，队列模式和订阅模式，可以发送给多个；给请求者应答，只要给到对应的消息队列即可，完  全不用关注具体的发送者地址；
* 如何表示数据格式，以保证不同架构之间读取？

  *原始方式*：约定格式来传送，但是发送的底层是二进制，接受者如果架构不一致，解析可能就会有问题

  *MQ*：不对消息强加任何格式，接收者解析跟发送者发送时一套标准，解析的内容跟发送的一致

* 如何处理网络错误？等待并重试，还是终止程序？

  *原始方式*：手动写程序定时重试，或者丢弃

  *MQ*：全可配置，配置重试次数或者直接不重试！


以上都是从网上找到的，据我的理解， 以下最关键的两个原因我们需要使用MQ

1. 大量消息需处理，MQ会负责为其排队，保证消息的不丢失，保证消息的安全
2. 分布式应用（尤其是不同架构的应用），只面向消息接口和消息响应的应用，松耦合，提高扩展性

什么情况下应该用ActiveMQ，以下是官方解释：
http://activemq.apache.org/use-cases.html
